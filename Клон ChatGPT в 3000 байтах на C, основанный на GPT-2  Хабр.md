---
created: 2025-02-06T02:39:26 (UTC +03:00)
tags: [gpt,трансформеры,C,нейронные сети]
source: https://habr.com/ru/articles/879662/
author: Sivchenko_translate
---

# Клон ChatGPT в 3000 байтах на C, основанный на GPT-2 / Хабр

> ## Excerpt
> Эта программа представляет собой свободную от зависимостей реализацию GPT-2. Она загружает матрицу весов и файл BPE из оригинальных файлов TensorFlow, токенизиру...

---
Эта программа представляет собой свободную от зависимостей реализацию GPT-2. Она загружает матрицу весов и файл BPE из оригинальных файлов TensorFlow, токенизирует вывод при помощи простого энкодера, работающего по принципу частотного кодирования, реализует базовый пакет для линейной алгебры, в котором заключены математические операции над матрицами, определяет архитектуру трансформера, выполняет инференс трансформера, а затем очищает вывод от токенов при помощи BPE-декодера. Всё это — примерно в 3000 байт на C.

Код достаточно эффективно оптимизирован — настолько, что малый GPT-2 на любой современной машине выдаёт отклик всего за несколько секунд. Чтобы этого добиться, я реализовал KV-кэширование и применил эффективный алгоритм перемножения матриц, а также добавил опциональный OMP-параллелизм.

Взяв это за основу, можно создать некий аналог Chat GPT — при условии, что вас не слишком волнует качество вывода (объективно говоря, вывод получается просто ужасный… но решение работает). Здесь есть некоторые глюки (особенно с обработкой символов в кодировке UTF-8), а для эксплуатации модели размером XL с широким контекстным окном может потребоваться ~100 ГБ оперативной памяти. Но, если вы просто набираете текст в кодировке ASCII при помощи малого GPT2, то такая модель должна нормально работать примерно везде.

Я выложил [весь код на GitHub](https://github.com/carlini/c-chat-gpt-2), поэтому можете свободно брать его там и экспериментировать с ним.

Эта программа состоит из следующих основных блоков (каждый из них сопровождается соответствующим кодом): <u>Библиотека для базовой матричной математики (700 байт)</u> <u>Быстрое перемножение матриц (300 байт)</u> <u>Слои нейронной сети (300 байт)</u> <u>Модель-трансформер (600 байт)</u> <u>Частотное кодирование (400 байт)</u> <u>ввод/вывод (200 байт)</u> <u>Загрузка весов (300 байт)</u> <u>Загрузка данных для частотного кодирования (300 байт)</u>

```
<span>#include&lt;stdio.h&gt;</span><br><span>#include&lt;stdlib.h&gt;</span><br><span>#include&lt;string.h&gt;</span><br><span>#include&lt;math.h&gt;</span><br><span>int</span> <span>U</span>,<span>C</span>,<span>K</span>,<span>c</span>,<span>d</span>,<span>S</span>,<span>zz</span>;<span>char</span><span>*</span><span>bpe</span>;<span>typedef</span> <span>struct</span>{<span>float</span><span>*</span><span>i</span>;<span>int</span> <span>j</span>,<span>k</span>;} <span>A</span>;<span>void</span><span>*</span><span>E</span>,<span>*</span><span>n</span>;<span>A</span><span>*</span><span>f</span>;<span>FILE</span><span>*</span><span>fp</span>;<br><span>#define N(i,j)for(int i=0; i&lt;j; i++)</span><br><span>A</span> <span>o</span>(<span>int</span> <span>j</span>,<span>int</span> <span>k</span>,<span>int</span> <span>i</span>){<span>float</span><span>*</span><span>a</span><span>=</span><span>E</span>;<span>E</span><span>+=</span><span>S</span><span>=</span><span>4</span><span>*</span><span>j</span><span>*</span><span>k</span>;<span>memset</span>(<span>a</span>,<span>0</span>,<span>S</span><span>*</span><span>i</span>);<span>A</span> <span>R</span><span>=</span>{ <span>a</span>,<span>j</span>,<span>k</span>} ;<span>return</span> <span>R</span>;}<br><span>#define I(R,B)A R(A a,float k){ N(i,a.j*a.k){ float b=a.i[i]; a.i[i]=B; } return a; }</span><br><span>I</span>(<span>l</span>,<span>b</span><span>/</span><span>k</span>)<span>I</span>(<span>q</span>,<span>b</span><span>+</span><span>k</span>)<span>I</span>(<span>u</span>,<span>1.</span><span>/</span><span>sqrt</span>(<span>b</span>))<span>I</span>(<span>z</span>,<span>exp</span>(<span>b</span>))<span>I</span>(<span>r</span>,<span>a</span>.<span>i</span>[(<span>i</span><span>/</span><span>a</span>.<span>k</span>)<span>*</span><span>a</span>.<span>k</span>])<span>I</span>(<span>P</span>,(<span>i</span><span>/</span><span>k</span><span>&lt;</span><span>i</span><span>%</span>(<span>int</span>)<span>k</span>)<span>?</span><span>0</span>:<span>exp</span>(<span>b</span><span>/</span><span>8</span>))<span>I</span>(<span>Q</span>,<span>b</span><span>/</span><span>2</span><span>*</span>(<span>1</span><span>+</span><span>tanh</span>(<span>.7978845</span><span>*</span>(<span>b</span><span>+</span><span>.044715</span><span>*</span><span>b</span><span>*</span><span>b</span><span>*</span><span>b</span>))))<br><span>#define F(R,B)A R(A a,A b){ N(i,a.j*a.k){ a.i[i]=a.i[i]B b.i[i]; } return a; }</span><br><span>F</span>(<span>V</span>,<span>+</span>)<span>F</span>(<span>v</span>,<span>*</span>)<span>F</span>(<span>H</span>,<span>/</span>)<span>F</span>(<span>at</span>,<span>+</span><span>b</span>.<span>i</span>[<span>i</span><span>%</span><span>a</span>.<span>k</span>];)<span>F</span>(<span>mt</span>,<span>*</span><span>b</span>.<span>i</span>[<span>i</span><span>%</span><span>a</span>.<span>k</span>];)<span>A</span> <span>X</span>(<span>A</span> <span>a</span>){<span>A</span> <span>R</span><span>=</span><span>o</span>(<span>a</span>.<span>j</span>,<span>a</span>.<span>k</span>,<span>1</span>);<span>N</span>(<span>i</span>,<span>a</span>.<span>j</span><span>*</span><span>a</span>.<span>k</span>)<span>R</span>.<span>i</span>[(<span>i</span><span>/</span><span>a</span>.<span>k</span>)<span>*</span><span>a</span>.<span>k</span>]<span>+=</span><span>a</span>.<span>i</span>[<span>i</span>];<span>r</span>(<span>R</span>,<span>0</span>);<span>return</span> <span>R</span>;}<span>A</span> <span>p</span>(<span>A</span> <span>a</span>){<span>A</span> <span>R</span><span>=</span><span>o</span>(<span>a</span>.<span>k</span>,<span>a</span>.<span>j</span>,<span>1</span>);<span>N</span>(<span>i</span>,<span>a</span>.<span>j</span><span>*</span><span>a</span>.<span>k</span>)<span>R</span>.<span>i</span>[<span>i</span><span>%</span><span>a</span>.<span>k</span><span>*</span><span>a</span>.<span>j</span><span>+</span><span>i</span><span>/</span><span>a</span>.<span>k</span>]<span>=</span><span>a</span>.<span>i</span>[<span>i</span>];<span>return</span> <span>R</span>;}<br><span>A</span> <span>g</span>(<span>A</span> <span>a</span>,<span>A</span> <span>b</span>){<span>A</span> <span>R</span><span>=</span><span>o</span>(<span>a</span>.<span>j</span>,<span>b</span>.<span>j</span>,<span>!</span><span>c</span>);{<span>for</span>(<span>int</span> <span>i</span><span>=</span><span>c</span>;<span>i</span><span>&lt;</span><span>d</span>;<span>i</span><span>++</span>){<span>for</span>(<span>int</span> <span>j</span><span>=</span><span>0</span>;<span>j</span><span>&lt;</span><span>b</span>.<span>j</span>;<span>j</span><span>+=</span><span>4</span>){<span>for</span>(<span>int</span> <span>k</span><span>=</span><span>0</span>;<span>k</span><span>&lt;</span><span>a</span>.<span>k</span>;<span>k</span><span>+=</span><span>4</span>){<span>N</span>(<span>k2</span>,<span>4</span>)<span>N</span>(<span>j2</span>,<span>4</span>)<span>R</span>.<span>i</span>[<span>i</span><span>*</span><span>b</span>.<span>j</span><span>+</span><span>j</span><span>+</span><span>j2</span>]<span>+=</span><span>a</span>.<span>i</span>[<span>i</span><span>*</span><span>a</span>.<span>k</span><span>+</span><span>k</span><span>+</span><span>k2</span>]<span>*</span><span>b</span>.<span>i</span>[(<span>j</span><span>+</span><span>j2</span>)<span>*</span><span>b</span>.<span>k</span><span>+</span><span>k</span><span>+</span><span>k2</span>];}}}}<span>return</span><br><span>V</span>(<span>o</span>(<span>R</span>.<span>j</span>,<span>R</span>.<span>k</span>,<span>1</span>),<span>R</span>);}<span>A</span> <span>J</span>(<span>A</span> <span>a</span>,<span>int</span> <span>b</span>,<span>int</span> <span>j</span>,<span>int</span> <span>k</span>){<span>A</span> <span>R</span><span>=</span>{ <span>a</span>.<span>i</span><span>+</span><span>b</span><span>*</span><span>j</span>,<span>j</span>,<span>k</span>} ;<span>return</span> <span>R</span>;}<span>A</span> <span>s</span>(<span>A</span> <span>a</span>,<span>int</span> <span>i</span>){<span>A</span> <span>b</span><span>=</span><span>V</span>(<span>a</span>,<span>l</span>(<span>X</span>(<span>a</span>),<span>-</span><span>a</span>.<span>k</span>));<span>A</span> <span>k</span><span>=</span><span>l</span>(<span>X</span>(<span>v</span>(<span>V</span>(<span>o</span>(<span>b</span>.<span>j</span>,<span>b</span>.<span>k</span>,<span>1</span>),<span>b</span>),<span>b</span>)),<span>b</span>.<span>k</span><span>-</span><span>1</span>);<span>A</span> <span>R</span><span>=</span><span>at</span>(<span>mt</span>(<span>v</span>(<span>V</span>(<span>o</span>(<span>b</span>.<span>j</span>,<span>b</span>.<span>k</span>,<span>1</span>),<span>b</span>),<span>u</span>(<span>q</span>(<span>k</span>,<span>1e</span><span>-</span><span>5</span>),<span>0</span>)),<span>f</span>[<span>i</span><span>+</span><span>1</span>]),<span>f</span>[<span>i</span>]);<span>return</span> <span>R</span>;}<br><span>#define G(a,i)at(g(a,f[i+1]),f[i])</span><br><span>A</span> <span>m</span>(<span>int</span> <span>j</span>,<span>int</span> <span>k</span>){<span>j</span><span>+=!</span><span>j</span>;<span>k</span><span>+=!</span><span>k</span>;<span>A</span> <span>a</span><span>=</span><span>o</span>(<span>j</span>,<span>k</span>,<span>1</span>);<span>fread</span>(<span>a</span>.<span>i</span>,<span>S</span>,<span>1</span>,<span>fp</span>);<span>return</span> <span>p</span>(<span>a</span>);}<br><span>int</span> <span>t</span>;<span>int</span> <span>Y</span>(<span>char</span><span>*</span><span>R</span>){<span>if</span>(<span>!*</span><span>R</span>)<span>return</span> <span>0</span>;<span>int</span> <span>B</span><span>=</span><span>1e9</span>,<span>r</span>;<span>N</span>(<span>i</span>,<span>5e4</span>){<span>if</span>(<span>bpe</span>[<span>999</span><span>*</span><span>i</span>]<span>&amp;&amp;</span><span>strncmp</span>(<span>bpe</span><span>+</span><span>999</span><span>*</span><span>i</span>,<span>R</span>,<span>S</span><span>=</span><span>strlen</span>(<span>bpe</span><span>+</span><span>999</span><span>*</span><span>i</span>))<span>==</span><span>0</span>){<span>int</span> <span>k</span><span>=</span><span>Y</span>(<span>R</span><span>+</span><span>S</span>)<span>+</span><span>i</span><span>+</span><span>1e7</span>;<span>if</span>(<span>k</span><span>&lt;</span><span>B</span>){<span>B</span><span>=</span><span>k</span>;<span>r</span><span>=</span><span>i</span>;}}}<span>t</span><span>=</span><span>r</span>;<span>return</span> <span>B</span>;}<span>int</span> <span>*</span><span>w</span>(<span>char</span><span>*</span><span>q</span>,<span>int</span><span>*</span><span>B</span>){<span>char</span> <span>R</span>[<span>1000</span>];<span>int</span> <span>i</span><span>=</span><span>0</span>;<span>while</span>(<span>q</span>[<span>i</span>]){<span>int</span> <span>j</span><span>=</span><span>i</span><span>++</span>;<span>while</span>(<span>47</span><span>&lt;</span><span>q</span>[<span>i</span>]<span>&amp;&amp;</span><span>q</span>[<span>i</span>]<span>&lt;</span><span>58</span><span>||</span><span>64</span><span>&lt;</span><span>q</span>[<span>i</span>]){<span>fflush</span>(<span>stdout</span>);<span>i</span><span>++</span>;}<span>strcpy</span>(<span>R</span>,<span>q</span><span>+</span><span>j</span>);<span>R</span>[<span>i</span><span>-</span><span>j</span>]<span>=</span><span>0</span>;<span>fflush</span>(<span>stdout</span>);<span>int</span> <span>k</span><span>=</span><span>0</span>;<span>while</span>(<span>R</span>[<span>k</span>]){<span>Y</span>(<span>R</span><span>+</span><span>k</span>);<span>char</span><span>*</span><span>M</span><span>=</span><span>bpe</span><span>+</span><span>t</span><span>*</span><span>999</span>;<span>k</span><span>+=</span><span>strlen</span>(<span>M</span>);<span>*</span><span>B</span><span>++=</span><span>t</span>;}}<span>return</span> <span>B</span>;}<br><span>int</span> <span>main</span>(<span>int</span> <span>S</span>,<span>char</span><span>*</span><span>*</span><span>D</span>){<span>S</span><span>=</span><span>D</span>[<span>1</span>][<span>5</span>]<span>+</span><span>3</span><span>*</span><span>D</span>[<span>1</span>][<span>7</span>]<span>+</span><span>3</span><span>&amp;</span><span>3</span>;<span>K</span><span>=</span><span>12</span><span>+</span><span>4</span><span>*</span><span>S</span><span>+</span>(<span>S</span><span>&gt;</span><span>2</span>);<span>U</span><span>=</span><span>K</span><span>*</span><span>64</span>;<span>C</span><span>=</span><span>12</span><span>*</span><span>S</span><span>+</span><span>12</span>;<span>zz</span><span>=</span><span>atoi</span>(<span>D</span>[<span>4</span>]);<span>E</span><span>=</span><span>malloc</span>(<span>2LL</span><span>*</span><span>U</span><span>*</span><span>U</span><span>*</span><span>C</span><span>*</span><span>zz</span>);<br><span>bpe</span><span>=</span><span>malloc</span>(<span>1e9</span>);<span>fp</span><span>=</span><span>fopen</span>(<span>D</span>[<span>2</span>],<span>"r"</span>);<span>unsigned</span> <span>char</span> <span>a</span>[<span>S</span><span>=</span><span>999</span>],<span>b</span>[<span>S</span>];<span>N</span>(<span>i</span>,<span>5e4</span>){<span>int</span> <span>k</span><span>=</span><span>i</span><span>*</span><span>S</span>;<span>if</span>(<span>i</span><span>&lt;</span><span>93</span>){<span>bpe</span>[<span>k</span>]<span>=</span><span>i</span><span>+</span><span>33</span>;<span>bpe</span>[<span>k</span><span>+</span><span>1</span>]<span>=</span><span>0</span>;} <span>else</span> <span>if</span>(<span>i</span><span>&gt;</span><span>254</span>){<span>fscanf</span>(<span>fp</span>,<span>"%s %s"</span>,<span>a</span>,<span>b</span>);<span>strcat</span>((<span>char</span><span>*</span>)<span>a</span>,(<span>char</span><span>*</span>)<span>b</span>);<span>int</span> <span>j</span><span>=</span><span>0</span>;<span>N</span>(<span>i</span>,<span>a</span>[<span>i</span>])<span>bpe</span>[<span>k</span><span>+</span><span>j</span><span>++</span>]<span>=</span><span>a</span>[<span>i</span>]<span>^196</span><span>?</span><span>a</span>[<span>i</span>]:<span>a</span>[<span>++</span><span>i</span>]<span>-</span><span>128</span>;<span>bpe</span>[<span>k</span><span>+</span><span>j</span><span>++</span>]<span>=</span><span>0</span>;} <span>else</span> <span>if</span>(<span>i</span><span>&gt;</span><span>187</span>){<span>bpe</span>[<span>k</span>]<span>=</span><span>i</span><span>-</span><span>188</span>;<span>bpe</span>[<span>k</span><span>+</span><span>1</span>]<span>=</span><span>0</span>;}}<span>int</span> <span>e</span>[<span>1024</span>];<span>d</span><span>=</span><span>w</span>(<span>D</span>[<span>3</span>],<span>e</span>)<span>-</span><span>e</span>;<span>int</span> <span>h</span>;<span>N</span>(<span>i</span>,<span>d</span>){<span>if</span>(<span>e</span>[<span>i</span>]<span>==</span><span>18861</span>)<span>h</span><span>=</span><span>i</span><span>+</span><span>1</span>;}<span>printf</span>(<span>"AI"</span>);<span>N</span>(<span>i</span>,<span>d</span><span>-</span><span>h</span>)<span>printf</span>(<span>"%s"</span>,<span>bpe</span><span>+</span><span>e</span>[<span>i</span><span>+</span><span>h</span>]<span>*</span><span>999</span>);<br><span>fp</span><span>=</span><span>fopen</span>(<span>D</span>[<span>1</span>],<span>"r"</span>);<span>A</span><span>\</span><br> <span>x</span>[<span>999</span>];<span>A</span><span>*</span><span>R</span><span>=</span><span>x</span>;<span>N</span>(<span>i</span>,<span>C</span>){<span>N</span>(<span>j</span>,<span>12</span>)<span>*</span><span>R</span><span>++=</span><span>m</span>(<span>U</span><span>+</span><span>U</span><span>*</span>(<span>j</span><span>?</span><span>j</span><span>^8</span><span>?</span><span>j</span><span>^11</span><span>?</span><span>0</span>:<span>3</span>:<span>3</span>:<span>2</span>),<span>U</span><span>*</span>((<span>j</span><span>%</span><span>8</span><span>==</span><span>3</span>)<span>+</span><span>3</span><span>*</span>(<span>j</span><span>%</span><span>8</span><span>==</span><span>1</span>)<span>+</span>(<span>j</span><span>==</span><span>9</span>)));}<span>*</span><span>R</span><span>++=</span><span>m</span>(<span>U</span>,<span>1</span>);<span>*</span><span>R</span><span>++=</span><span>m</span>(<span>U</span>,<span>1</span>);<span>A</span> <span>QA</span><span>=</span><span>m</span>(<span>1024</span>,<span>U</span>),<span>Z</span><span>=</span><span>p</span>(<span>m</span>(<span>5e4</span>,<span>U</span>));<br><span>while</span>(<span>1</span>){<span>char</span> <span>W</span>[<span>1000</span>]<span>=</span>{ <span>0</span>} ;<span>int</span> <span>T</span>;<span>strcat</span>(<span>W</span>,<span>"\nAlice: "</span>);<span>printf</span>(<span>"\n%s: "</span>,<span>bpe</span><span>+</span><span>20490</span><span>*</span><span>999</span>);<span>fflush</span>(<span>stdout</span>);<span>fgets</span>(<span>W</span><span>+</span><span>8</span>,<span>1000</span>,<span>stdin</span>);<span>printf</span>(<span>"AI:"</span>);<span>strcat</span>(<span>W</span>,<span>"\nBob:"</span>);<span>d</span><span>=</span><span>w</span>(<span>W</span>,<span>e</span><span>+</span><span>d</span>)<span>-</span><span>e</span>;<span>n</span><span>=</span><span>E</span>;<span>c</span><span>=</span><span>0</span>;<br><span>while</span>(<span>1</span>){<span>E</span><span>=</span><span>n</span>;<span>T</span><span>=</span><span>d</span><span>+</span><span>32</span><span>-</span><span>d</span><span>%</span><span>32</span>;<span>c</span><span>*=!!</span>(<span>d</span><span>%</span><span>32</span>);<span>A</span> <span>O</span><span>=</span><span>o</span>(<span>T</span>,<span>U</span>,<span>1</span>);<span>N</span>(<span>i</span>,<span>d</span>){<span>N</span>(<span>j</span>,<span>U</span>)<span>O</span>.<span>i</span>[<span>i</span><span>*</span><span>U</span><span>+</span><span>j</span>]<span>=</span><span>Z</span>.<span>i</span>[<span>e</span>[<span>i</span>]<span>*</span><span>U</span><span>+</span><span>j</span>]<span>+</span><span>QA</span>.<span>i</span>[<span>j</span><span>*</span><span>1024</span><span>+</span><span>i</span>];}<span>N</span>(<span>i</span>,<span>C</span>){<span>int</span> <span>y</span>;<span>S</span><span>=</span><span>0</span>;<span>N</span>(<span>j</span>,<span>10</span>){<span>if</span>(<span>j</span><span>==</span><span>i</span>)<span>y</span><span>=</span><span>S</span>;<span>S</span><span>++</span>;<span>N</span>(<span>k</span>,<span>10</span><span>*</span>(<span>j</span><span>&gt;</span><span>0</span>)){<span>if</span>(<span>j</span><span>*</span><span>10</span><span>+</span><span>k</span><span>&lt;</span><span>C</span><span>&amp;&amp;</span><span>S</span><span>++&amp;&amp;</span><span>i</span><span>==</span><span>j</span><span>*</span><span>10</span><span>+</span><span>k</span>)<span>y</span><span>=</span><span>S</span>;}}<span>f</span><span>=</span><span>x</span><span>+</span><span>12</span><span>*</span><span>y</span>;<span>A</span> <span>QB</span><span>=</span><span>p</span>(<span>J</span>(<span>G</span>(<span>s</span>(<span>O</span>,<span>4</span>),<span>0</span>),<span>0</span>,<span>T</span><span>*</span><span>3</span>,<span>U</span>));<span>A</span> <span>B</span><span>=</span><span>o</span>(<span>U</span>,<span>T</span>,<span>1</span>);<span>N</span>(<span>k</span>,<span>K</span>){<span>A</span> <span>L</span><span>=</span><span>p</span>(<span>J</span>(<span>QB</span>,<span>k</span><span>*</span><span>3</span>,<span>64</span><span>*</span><span>T</span>,<span>3</span>)),<span>a</span><span>=</span><span>P</span>(<span>g</span>(<span>p</span>(<span>J</span>(<span>L</span>,<span>0</span>,<span>64</span>,<span>T</span>)),<span>p</span>(<span>J</span>(<span>L</span>,<span>T</span>,<span>64</span>,<span>T</span>))),<span>T</span>),<span>R</span><span>=</span><span>p</span>(<span>g</span>(<span>H</span>(<span>a</span>,<span>X</span>(<span>a</span>)),<span>J</span>(<span>L</span>,<span>T</span><span>*</span><span>2</span>,<span>64</span>,<span>T</span>)));<span>memcpy</span>(<span>B</span>.<span>i</span><span>+</span><span>64</span><span>*</span><span>T</span><span>*</span><span>k</span>,<span>R</span>.<span>i</span>,<span>64</span><span>*</span><span>T</span><span>*</span><span>4</span>);}<span>O</span><span>=</span><span>V</span>(<span>O</span>,<span>G</span>(<span>p</span>(<span>B</span>),<span>2</span>));<span>O</span><span>=</span><span>V</span>(<span>O</span>,<span>G</span>(<span>Q</span>(<span>G</span>(<span>s</span>(<span>O</span>,<span>6</span>),<span>8</span>),<span>0</span>),<span>10</span>));}<span>f</span><span>=</span><span>x</span>;<span>O</span><span>=</span><span>s</span>(<span>O</span>,<span>12</span><span>*</span><span>C</span>);<span>c</span><span>=</span><span>0</span>;<span>int</span> <span>S</span><span>=</span><span>d</span>;<span>d</span><span>=</span><span>1</span>;<span>A</span> <span>B</span><span>=</span><span>g</span>(<span>p</span>(<span>J</span>(<span>O</span>,<span>S</span><span>-</span><span>1</span>,<span>U</span>,<span>1</span>)),<span>Z</span>);<span>c</span><span>=</span><span>d</span><span>=</span><span>S</span>;<span>S</span><span>=</span><span>0</span>;<span>N</span>(<span>i</span>,<span>5e4</span>){<span>if</span>(<span>B</span>.<span>i</span>[<span>i</span>]<span>&gt;</span><span>B</span>.<span>i</span>[<span>S</span>])<span>S</span><span>=</span><span>i</span>;}<span>if</span>(<span>d</span><span>==</span><span>zz</span>){<span>memcpy</span>(<span>e</span>,<span>e</span><span>+</span><span>zz</span><span>/</span><span>2</span>,<span>S</span><span>*</span><span>2</span>);<span>d</span><span>-=</span><span>zz</span><span>/</span><span>2</span>;<span>c</span><span>=</span><span>0</span>;}<span>e</span>[<span>d</span><span>++</span>]<span>=</span><span>S</span>;<br><span>if</span>(<span>bpe</span>[<span>S</span><span>*</span><span>999</span>]<span>==</span><span>10</span>)<span>break</span>;<span>printf</span>(<span>"%s"</span>,<span>bpe</span><span>+</span><span>S</span><span>*</span><span>999</span>);<span>fflush</span>(<span>stdout</span>);}}}
```

## Контекст: ChatGPT и трансформеры

Тем, кто в танке — напомню, что ChatGPT — это такое приложение. В нём вы можете общаться с так называемой «(большой) языковой моделью» как с собеседником-человеком. Она удивительно хорошо поддерживает разговор, а GPT-4, новейшая модель, лежащая в основе ChatGPT, вообще невероятно впечатляет.

В данной программе на C воспроизведено поведение ChatGPT, но при помощи гораздо более слабой модели GPT-2, появившейся ещё в 2019 году. Несмотря на то, что номер версии у неё всего на 2 меньше, чем у GPT-4, возможности их просто несопоставимы — зато модель GPT-2 является опенсорсной. Поэтому с ней и будем работать.

[GPT-2](https://d4mucfpksywv.cloudfront.net/better-language-models/language_models_are_unsupervised_multitask_learners.pdf) — это тип моделей машинного обучения, так называемый  [«трансформер»](https://arxiv.org/abs/1706.03762) . Такие нейронные сети принимают на вход фиксированную последовательность слов, после чего прогнозируют слово, которое должно идти следующим. Вновь и вновь повторяя эту процедуру, можно генерировать при помощи трансформера лексические последовательности произвольной длины.

В этом посте я не собираюсь делать настолько полный экскурс в машинное обучение, после которого вы бы уяснили, _почему_ трансформер спроектирован так, а не иначе. Далее просто будет описано, как именно работает вышеприведённый код на C.

## Разбор кода C

**Начнём: матричная математика (700 байт)**

Вся «картина мира» нейронной сети заключена в матричных операциях. Поэтому для начала нам потребуется соорудить библиотеку для работы с матрицами, потратив на это минимум байт.

Вот совершенно минимальное определение матрицы:

```
<span>typedef</span> <span>struct</span> {<br>  <span>float</span><span>*</span> <span>dat</span>;<br>  <span>int</span> <span>rows</span>, <span>cols</span>;<br>} <span>Matrix</span>;
```

Для начала отметим, что, пусть нам и требуется реализовать целый ряд различных операций, все они делятся на два принципиальных «типа»:

1.     Матрично-константные операции (напр., прибавить 7 к каждой из записей в матрице)

2.     Матрично-матричные операции (напр., сложить соответствующие матричные записи)

Благодаря такому сходству можно воспользоваться макросами и вытянуть некоторую общую логику в метапроцедуру, в которой прописано, например, как обращаться с парами матриц. В таком случае детали конкретных операций будут зависеть от реализации.

Чтобы сделать это на C, определим функцию

```
<span>#define BINARY(function, operation)</span>
```

как

```
<span>Matrix</span> <span>FUNCTION</span>(<span>Matrix</span> <span>a</span>, <span>Matrix</span> <span>b</span>) {<br>  <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>a</span>.<span>rows</span>; <span>i</span><span>++</span>) {<br>    <span>for</span> (<span>int</span> <span>j</span> <span>=</span> <span>0</span>; <span>j</span> <span>&lt;</span> <span>a</span>.<span>cols</span>; <span>j</span><span>++</span>) {<br>      <span>a</span>[<span>i</span><span>*</span><span>a</span>.<span>cols</span> <span>+</span> <span>j</span>] <span>=</span> <span>a</span>[<span>i</span><span>*</span><span>a</span>.<span>cols</span> <span>+</span> <span>j</span>] <span>OPERATION</span> <span>b</span>[<span>i</span><span>*</span><span>a</span>.<span>cols</span><span>+</span><span>j</span>];<br>    }<br>  }<br>  <span>return</span> <span>a</span>;<br>}
```

Что, например, позволит нам написать

```
<span>BINARY</span>(<span>matrix_elementwise_add</span>, <span>+</span>);<br><span>BINARY</span>(<span>matrix_elementwise_multiply</span>, <span>*</span>);
```

и предусмотреть возможность расширения до полной операции, в рамках которой происходило бы поэлементное сложение или перемножение двух матриц. Определю ещё несколько операций, понять которые не составляет труда:

Теперь остановимся на принятых в C `#defines`. В сущности, это просто расфуфыренные регулярные выражения. Поэтому, когда запустим такой `#define`, в программе на самом деле произойдёт

```
<span>a</span>[<span>i</span><span>*</span><span>a</span>.<span>cols</span> <span>+</span> <span>j</span>] <span>=</span> <span>a</span>[<span>i</span><span>*</span><span>a</span>.<span>cols</span> <span>+</span> <span>j</span>] <span>OPERATION</span> <span>b</span>[<span>i</span><span>*</span><span>a</span>.<span>cols</span><span>+</span><span>j</span>];
```

что в случае с умножением расширится до

```
<span>a</span>[<span>i</span><span>*</span><span>a</span>.<span>cols</span> <span>+</span> <span>j</span>] <span>=</span> <span>a</span>[<span>i</span><span>*</span><span>a</span>.<span>cols</span> <span>+</span> <span>j</span>] <span>*</span> <span>b</span>[<span>i</span><span>*</span><span>a</span>.<span>cols</span><span>+</span><span>j</span>];
```

На первый взгляд этот код выглядит довольно запутанно — например, что здесь делает эта точка с запятой? Но, если вы просто замените код регулярным выражением, то увидите, как он расширяется до

```
  <span>a</span>[<span>i</span><span>*</span><span>a</span>.<span>cols</span> <span>+</span> <span>j</span>] <span>=</span> <span>a</span>[<span>i</span><span>*</span><span>a</span>.<span>cols</span> <span>+</span> <span>j</span>] <span>+</span> <span>b</span>.<span>dat</span>[<span>i</span><span>%</span><span>a</span>.<span>cols</span>] ; <span>b</span>[<span>i</span><span>*</span><span>a</span>.<span>cols</span><span>+</span><span>j</span>];
```

Поскольку второе выражение здесь ничего не делает, этот код фактически эквивалентен

```
<span>a</span>[<span>i</span><span>*</span><span>a</span>.<span>cols</span> <span>+</span> <span>j</span>] <span>=</span> <span>a</span>[<span>i</span><span>*</span><span>a</span>.<span>cols</span> <span>+</span> <span>j</span>] <span>+</span> <span>b</span>.<span>dat</span>[<span>i</span><span>%</span><span>a</span>.<span>cols</span>] ; <span>b</span>[<span>i</span><span>*</span><span>a</span>.<span>cols</span><span>+</span><span>j</span>];
```

a\[i\*a.cols + j\] = a\[i\*a.cols + j\] + b.dat\[i%a.cols\] ; b\[i\*a.cols+j\];

(ПОЛЬЗУЙТЕСЬ ЯЗЫКАМИ С КАЧЕСТВЕННЫМИ МАКРОСАМИ. LISP НЕ ВСЕГДА ЛУЧШЕ C!)

**Быстрое перемножение матриц (300 байт)**

Базовая реализация перемножения матриц совершенно проста: мы всего лишь реализуем тривиальные циклы с кубической вычислительной сложностью. (В моём примере с перемножением матриц нет ничего особенного. Если вы умеете быстро перемножать матрицы, то просто следите за кодом).

```
<span>Matrix</span> <span>matmul</span>(<span>Matrix</span> <span>a</span>, <span>Matrix</span> <span>b</span>) {<br>  <span>Matrix</span> <span>out</span> <span>=</span> <span>NewMatrix</span>(<span>a</span>.<span>rows</span>, <span>b</span>.<span>rows</span>);<br>  <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>a</span>.<span>rows</span>; <span>i</span><span>++</span>)<br>    <span>for</span> (<span>int</span> <span>j</span> <span>=</span> <span>0</span>; <span>j</span> <span>&lt;</span> <span>b</span>.<span>rows</span>; <span>j</span><span>++</span>)<br>      <span>for</span> (<span>int</span> <span>k</span> <span>=</span> <span>0</span>; <span>k</span> <span>&lt;</span> <span>a</span>.<span>cols</span>; <span>k</span><span>++</span>)<br>        <span>out</span>.<span>dat</span>[<span>i</span> <span>*</span> <span>b</span>.<span>rows</span> <span>+</span> <span>j</span>] <span>+=</span> <span>a</span>.<span>dat</span>[<span>i</span> <span>*</span> <span>a</span>.<span>cols</span> <span>+</span> <span>k</span><span>+</span><span>k2</span>] <span>*</span> <span>b</span>.<span>dat</span>[(<span>j</span><span>+</span><span>j2</span>) <span>*</span> <span>b</span>.<span>cols</span> <span>+</span> <span>k</span>];<br><br><br>  <span>return</span> <span>out</span>;<br>}
```

К счастью, эту процедуру можно значительно ускорить, сделав её лишь немного умнее. Учитывая, как именно на большинстве компьютеров работают память и кэш, можно (значительно!) ускорить работу, если многократно читать один и тот же фрагмент памяти, а также записывать в него.

```
<span>Matrix</span> <span>matmul_t_fast</span>(<span>Matrix</span> <span>a</span>, <span>Matrix</span> <span>b</span>) {<br>  <span>Matrix</span> <span>out</span> <span>=</span> <span>NewMatrix</span>(<span>a</span>.<span>rows</span>, <span>b</span>.<span>rows</span>);<br>  <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>a</span>.<span>rows</span>; <span>i</span><span>++</span>)<br>    <span>for</span> (<span>int</span> <span>j</span> <span>=</span> <span>0</span>; <span>j</span> <span>&lt;</span> <span>b</span>.<span>rows</span>; <span>j</span> <span>+=</span> <span>4</span>)<br>      <span>for</span> (<span>int</span> <span>k</span> <span>=</span> <span>0</span>; <span>k</span> <span>&lt;</span> <span>a</span>.<span>cols</span>; <span>k</span> <span>+=</span> <span>4</span>)<br>        <span>for</span> (<span>int</span> <span>k2</span> <span>=</span> <span>0</span>; <span>k2</span> <span>&lt;</span> <span>4</span>; <span>k2</span> <span>+=</span> <span>1</span>)<br>          <span>for</span> (<span>int</span> <span>j2</span> <span>=</span> <span>0</span>; <span>j2</span> <span>&lt;</span> <span>4</span>; <span>j2</span> <span>+=</span> <span>1</span>)<br>            <span>out</span>.<span>dat</span>[<span>i</span> <span>*</span> <span>b</span>.<span>rows</span> <span>+</span> <span>j</span><span>+</span><span>j2</span>] <span>+=</span> <span>a</span>.<span>dat</span>[<span>i</span> <span>*</span> <span>a</span>.<span>cols</span> <span>+</span> <span>k</span><span>+</span><span>k2</span>] <span>*</span> <span>b</span>.<span>dat</span>[(<span>j</span><span>+</span><span>j2</span>) <span>*</span> <span>b</span>.<span>cols</span> <span>+</span> <span>k</span><span>+</span><span>k2</span>];<br><br><br>  <span>return</span> <span>out</span>;<br>}
```

Позже мы внесём ещё одно изменение в механизм логического вывода, а также добавим к перемножению матриц ещё один параметр, который позволит нам лишь частично умножать матрицу A на матрицу B. Это полезно в случаях, когда мы успели предварительно вычислить часть произведения.

**Слои нейронной сети (300 байт)**

Чтобы написать трансформер, потребуется определить несколько специфических слоёв нейронной сети. Один из них — это функция активации [GELU](https://arxiv.org/abs/1606.08415), которую можете воспринимать как колдовскую.

```
<span>UNARY</span>(<span>GELU</span>, <span>b</span> <span>/</span> <span>2</span> <span>*</span> (<span>1</span> <span>+</span> <span>tanh</span>(<span>.7978845</span> <span>*</span> (<span>b</span> <span>+</span> <span>.044715</span> <span>*</span> <span>b</span> <span>*</span> <span>b</span> <span>*</span> <span>b</span>))))
```

Также я реализую функцию, задающую нижнюю диагональ матрицы (после возведения значений в степень). Это пригодится нам для так называемого _причинного внимания_: мы собираемся учитывать только прошлое, но не будущее, поэтому при помощи данной функции устанавливаем нижнюю диагональ матрицы внимания в ноль.

```
<span>UNARY</span>(<span>tril</span>, (<span>i</span><span>/</span><span>k</span><span>&lt;</span><span>i</span><span>%</span>(<span>int</span>)<span>k</span>) <span>?</span> <span>0</span> : <span>exp</span>(<span>b</span><span>/</span><span>8</span>))
```

Наконец, нам понадобится функция нормализации слоёв (ещё одна магическая вещь, о которой можете сами почитать подробнее, если захотите. В сущности, она нормализует среднее и дисперсию каждого слоя).  

```
<span>Matrix</span> <span>LayerNorm</span>(<span>Matrix</span> <span>a</span>, <span>int</span> <span>i</span>) {<br>  <span>Matrix</span> <span>b</span> <span>=</span> <span>add</span>(<span>a</span>, <span>divide_const</span>(<span>sum</span>(<span>a</span>), <span>-</span><span>a</span>.<span>cols</span>));<br>  <span>Matrix</span> <span>k</span> <span>=</span> <span>divide_const</span>(<span>sum</span>(<span>multiply</span>(<br>    <span>add</span>(<span>NewMatrix</span>(<span>b</span>.<span>rows</span>,<span>b</span>.<span>cols</span>,<span>1</span>),<span>b</span>), <span>b</span>)), <span>b</span>.<span>cols</span><span>-</span><span>1</span>);<br>  <span>Matrix</span> <span>out</span> <span>=</span> <span>add_tile</span>(<span>multiply_tile</span>(<br>    <span>multiply</span>(<span>add</span>(<span>NewMatrix</span>(<span>b</span>.<span>rows</span>,<span>b</span>.<span>cols</span>,<span>1</span>),<span>b</span>),<br>    <span>mat_isqrt</span>(<span>add_const</span>(<span>k</span>, <span>1e</span><span>-</span><span>5</span>),<span>0</span>)), <span>layer_weights</span>[<span>i</span><span>+</span><span>1</span>]),<br>                        <span>layer_weights</span>[<span>i</span>]);<br><br><br>  <span>return</span> <span>out</span>;<br>}
```

Последний элемент модели — это линейная функция, просто перемножающая матрицы и плюсующая сдвиг (с разбиением на макрооперации — тайлингом).

```
<span>#define Linear(a, i) add_tile(matmul_t_fast(a, layer_weights[i+1]), layer_weights[i])</span>
```

**Архитектура трансформера (600 байт)**

Решив все эти вопросы, мы, наконец, сможем реализовать наш трансформер всего в 600 байтах.

```
<span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>NLAYER</span>; <span>i</span><span>++</span>) {<br>  <span>layer_weights</span> <span>=</span> <span>weights</span> <span>+</span> <span>12</span><span>*</span><span>permute</span>;<br><br><br>  <span>// Вычисляем ключи, запросы и значение — всё за одну большую операцию умножения </span><br>  <span>Matrix</span> <span>qkv</span> <span>=</span> <span>transpose</span>(<span>slice</span>(<span>Linear</span>(<span>LayerNorm</span>(<span>line</span>, <span>4</span>), <span>0</span>), <span>0</span>, <span>T</span><span>*</span><span>3</span>, <span>DIM</span>));<br><br><br>  <span>// Освобождаем место для вывода из вычислений </span><br>  <span>Matrix</span> <span>result</span> <span>=</span> <span>NewMatrix</span>(<span>DIM</span>, <span>T</span>, <span>1</span>);<br><br><br>  <span>for</span> (<span>int</span> <span>k</span> <span>=</span> <span>0</span>; <span>k</span> <span>&lt;</span> <span>NHEAD</span>; <span>k</span><span>++</span>) {<br>    <span>// Распределяем qkv на три вычислительные головы </span><br>    <span>Matrix</span> <span>merge</span> <span>=</span> <span>transpose</span>(<span>slice</span>(<span>qkv</span>, <span>k</span><span>*</span><span>3</span>, <span>64</span><span>*</span><span>T</span>, <span>3</span>)),<br>      <span>// Получаем произведение запросов и ключей, а затем возводим результат в степень </span><br>      <span>a</span> <span>=</span> <span>tril</span>(<span>matmul_t_fast</span>(<span>transpose</span>(<span>slice</span>(<span>merge</span>, <span>0</span>, <span>64</span>, <span>T</span>)),<br>                             <span>transpose</span>(<span>slice</span>(<span>merge</span>, <span>T</span>, <span>64</span>, <span>T</span>))), <span>T</span>),<br>      <span>// наконец, умножаем вывод softmax (a/sum(a)) на матрицу значеемй</span><br>      <span>out</span> <span>=</span> <span>transpose</span>(<span>matmul_t_fast</span>(<span>divide</span>(<span>a</span>, <span>sum</span>(<span>a</span>)), <span>slice</span>(<span>merge</span>, <span>T</span><span>*</span><span>2</span>, <span>64</span>, <span>T</span>)));<br>    <span>// и копируем вывод в ту часть результирующей матрицы, где он должен находиться </span><br>    <span>memcpy</span>(<span>result</span>.<span>dat</span><span>+</span><span>64</span><span>*</span><span>T</span><span>*</span><span>k</span>, <span>out</span>.<span>dat</span>, <span>64</span><span>*</span><span>T</span><span>*</span><span>4</span>);<br>  }<br><br><br>  <span>// Остаточная связь</span><br>  <span>line</span> <span>=</span> <span>add</span>(<span>line</span>,<span>Linear</span>(<span>transpose</span>(<span>result</span>), <span>2</span>));<br><br><br>  <span>// Функция активации и остаточная связь</span><br>  <span>line</span> <span>=</span> <span>add</span>(<span>line</span>, <span>Linear</span>(<span>GELU</span>(<span>Linear</span>(<span>LayerNorm</span>(<span>line</span>, <span>6</span>), <span>8</span>), <span>0</span>), <span>10</span>));<br>}<br><br><br><span>// Сбросить веса слоёв так, чтобы последний слой можно было взять за норму </span><br><span>layer_weights</span> <span>=</span> <span>weights</span>;<br><span>line</span> <span>=</span> <span>LayerNorm</span>(<span>line</span>, <span>12</span><span>*</span><span>NLAYER</span>);<br><br><br><span>Matrix</span> <span>result</span> <span>=</span> <span>matmul_t_fast</span>(<span>transpose</span>(<span>slice</span>(<span>line</span>, <span>tmp</span><span>-</span><span>1</span>, <span>DIM</span>, <span>1</span>)), <span>wte</span>);
```

Теперь озвучу один момент о логическом выводе в трансформерах, для вас, возможно, полностью очевидный. Когда вы уже вызвали модель, приказав ей сгенерировать один токен, вам не приходится перевычислять всю функцию для генерации следующего токена. На самом деле, для генерации каждого последующего токена требуется выполнить лишь минимум работы.  

Дело в том, что как только вы вычислили вывод трансформера для всех токенов вплоть до N-го, вы можете повторно использовать почти весь этот вывод для вычисления N+1го токена (выполнив еще немного работы.)

Чтобы всё это реализовать, я выстроил все операции выделения памяти у меня в коде последовательно, в пределах одного и того же блока памяти. Так гарантируется, что при любой операции матричного умножения будет задействована одна и та же память. Соответственно, на каждой итерации цикла я могу не обнулять память перед тем, как задействовать её на следующей итерации, и в памяти уже будет содержаться результат предыдущей итерации. Мне просто потребуется выполнить вычисление для N+й строки.

**Частотное кодирование (400 байт)**

Проще всего выстроить языковую модель на базе последовательности слов. Но, поскольку общее множество слов, в сущности, не ограничено, для любой языковой модели требуется ввод фиксированного размера, где понадобится заменить достаточно редкие слова специальным токеном \[OUT OF DISTRIBUTION\] (вне обучающего распределения). Это нехорошо.

Да, существует простейшее средство, позволяющее с этим справиться — использовать модели, работающие «на уровне символов» и поэтому знающие только отдельные буквы. Но здесь же возникает проблема: фактически, такой модели придётся изучать значение каждого слова с чистого листа. Также из-за этого сузится реальный размер контекстного окна языковой модели, и коэффициент такого снижения равен средней длине слова. 

Во избежание таких проблем модели вроде GPT-2 создают токены из «подслов». Некоторые слова могут быть токенами сами по себе, но редкие слова дополнительно дробятся. Например, слово «nicholas» можно подразделить на  «nich», «o», «las».

Реализовать общий алгоритм для этой цели не составляет труда: берём слово, которое хотим токенизировать, и сначала разделяем его на отдельные символы. Затем ищем пары таких смежных токенов, которые можно было бы объединить, и если находим — объединяем. Повторяем процедуру до тех пор, пока вариантов для дальнейшего слияния не останется.

При всей простоте этот алгоритм, к сожалению, очень трудно реализовать на C, так как для него требуется многократно выделять память и отслеживать развитие древовидной структуры токенов.

Поэтому в таком случае мы превращаем достаточно простой алгоритм с линейной сложностью в алгоритм с потенциально экспоненциальной сложностью, зато пишем гораздо меньше кода. Базовая идея будет раскрываться примерно так, как показано в этом C-подобном псевдокоде:

```
<span>word_tokenize</span>(<span>word</span>) {<br>  <span>if</span> <span>len</span>(<span>word</span>) <span>==</span> <span>0</span> { <span>return</span> (<span>0</span>, <span>0</span>); }<br>  <span>result</span> <span>=</span> (<span>1e9</span>, <span>-</span><span>1</span>);<br>  <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>VOCAB_LEN</span>; <span>i</span><span>++</span>) {<br>    <span>if</span> (<span>is_prefix</span>(<span>bpe</span>[<span>i</span>]), <span>word</span>) {<br>      <span>sub_cost</span> <span>=</span> <span>word_tokenize</span>(<span>word</span><span>+</span><span>len</span>(<span>bpe</span>[<span>i</span>]))[<span>0</span>] <span>+</span> <span>i</span> <span>+</span> <span>1e7</span>;<br>      <span>result</span> <span>=</span> <span>min</span>(<span>result</span>, (<span>sub_cost</span>, <span>i</span>));<br>    }<br>  }<br>  <span>return</span> <span>result</span>;<br>}
```

То есть, чтобы токенизировать слово, требуется проверить все возможные слова из словаря и узнать, не является ли оно префиксом актуального слова. Если является, то мы возьмём его в качестве первого токена, а затем попытаемся таким же образом рекурсивно токенизировать всё слово. Мы будем следить, какой вариант токенизации получается наилучшим (об этом судим по длине, ничейные результаты распределяем по индексу токена в словаре) — и именно его возвращаем.

**Загрузка весов (300 байт)**

Почти готово! Последнее, что нам осталось сделать — загрузить с диска в нейронную сеть фактические веса. Это на самом деле не сложно, поскольку веса хранятся в простом двоичном формате, который легко считывается в C. Фактически, это совершенно плоская сериализация 32-разрядных чисел с плавающей точкой.

Единственное, что требуется узнать — насколько велики различные матрицы. К счастью, это также легко выяснить. Каков бы ни был размер модели GPT-2, архитектура у них у всех одинакова, и веса хранятся в одном и том же порядке. Поэтому нам всего лишь требуется прочитать с диска правильно оформленные матрицы.

Но вот напоследок ложка дёгтя. Слои нейронной сети не хранятся на диске в том порядке, в котором следовало бы ожидать: сначала слой 0, затем слой 1, далее слой 2. На самом деле, первым идёт слой 0, за ним слой 1, а потом слой .... ДЕСЯТЬ! (и далее слой 11, а за ним 12.) Дело в том, что при сохранении веса сортируются по лексикографическому принципу. А лексикографически «0» предшествует «1», но «10» предшествует «2». Поэтому нам потребуется немного поработать, чтобы переставить веса в правильном порядке. Для этого напишем следующий код

```
<span>int</span> <span>permute</span>;<br><span>tmp</span><span>=</span><span>0</span>;<br><span>for</span> (<span>int</span> <span>j</span> <span>=</span> <span>0</span>; <span>j</span> <span>&lt;</span> <span>10</span>; <span>j</span><span>++</span>) {<br>  <span>if</span> (<span>j</span> <span>==</span> <span>i</span>) {<br>    <span>permute</span> <span>=</span> <span>tmp</span>;<br>  }<br>  <span>tmp</span><span>++</span>;<br>  <span>for</span> (<span>int</span> <span>k</span> <span>=</span> <span>0</span>; <span>k</span> <span>&lt;</span> <span>10</span><span>*</span>(<span>j</span><span>&gt;</span><span>0</span>); <span>k</span><span>++</span>) {<br>    <span>if</span> (<span>j</span><span>*</span><span>10</span><span>+</span><span>k</span> <span>&lt;</span> <span>NLAYER</span> <span>&amp;&amp;</span> <span>tmp</span><span>++</span> <span>&amp;&amp;</span> <span>i</span> <span>==</span> <span>j</span><span>*</span><span>10</span><span>+</span><span>k</span>) {<br>      <span>permute</span> <span>=</span> <span>tmp</span>;<br>    }<br>  }<br>}
```

**Загрузка данных для частотного кодирования (300 байт)**

Чтобы фактически осуществить частотное кодирование, мы сначала должны загрузить с диска словарь с соответствующими байтовыми парами. В идеале хотелось бы иметь список всех слов из словаря, сохранённых в каком-нибудь вменяемом C-читаемом формате. Но поскольку исходный файл (a) рассчитан на чтение в Python и (b) не предназначен для лёгкого синтаксического разбора минимальных байтовых фрагментов, нам здесь придётся потрудиться.

Логично предположить, что формат файла предусматривает просто список идущих друг за другом слов, но на самом деле информация в нём закодирована в виде списка байтовых пар. То есть, мы сможем прочитать в качестве одного токена не «Hello», а строку «H» «ello». Таким образом, нам следует объединить токены «H» и «ello» в один токен «Hello».

Другая проблема заключается в том, что файл представлен в сглаживающей кодировке UTF-8 (с оговорками) и ... на то есть причина. Все символы ascii, которые можно вывести на печать, кодируются сами по себе, а «невыводимые» символы 0-31 кодируются в формате 188+символ. Так, например, пробел кодируется в виде токена  «Ġ». Но вот проблема: в кодировке UTF8 на диске символу «Ġ» соответствует 0xc4 0xa0. Поэтому при считывании нам придётся приложить усилия, чтобы преобразовать этот символ обратно в пробел.

Притом, что всё это, в принципе, ничто из этого не сложно, для всех этих операций требуется написать много кода. Это, конечно, раздражает, когда стремишься к максимальной компактности.

```
<span>unsigned</span> <span>char</span> <span>a</span>[<span>tmp</span><span>=</span><span>999</span>],<span>b</span>[<span>tmp</span>];<br><span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>5e4</span>; <span>i</span><span>++</span>) {<br>  <span>int</span> <span>k</span> <span>=</span> <span>i</span><span>*</span><span>tmp</span>;<br>  <span>if</span> (<span>i</span> <span>&lt;</span> <span>93</span>) {<br>    <span>// Первые 92 токена – это просто символы ascii, выводимые на печать</span><br>    <span>bpe</span>[<span>k</span>] <span>=</span> <span>i</span> <span>+</span> <span>33</span>;<br>    <span>bpe</span>[<span>k</span><span>+</span><span>1</span>] <span>=</span> <span>0</span>;<br>  } <span>else</span> <span>if</span> (<span>i</span> <span>&gt;</span> <span>254</span>) {<br>    <span>// Те, что сверх 254, взяты из файла BPE. Загружаем их </span><br>    <span>fscanf</span>(<span>fp</span>, <span>"%s %s"</span>, <span>a</span>, <span>b</span>);<br>    <span>strcat</span>((<span>char</span><span>*</span>)<span>a</span>, (<span>char</span><span>*</span>)<span>b</span>);<br>    <span>int</span> <span>j</span> <span>=</span> <span>0</span>;<br>  <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>a</span>[<span>i</span>]; <span>i</span><span>++</span>) {<br>    <span>// Кодировка UTF8 усложняет жизнь, поэтому обрабатываем её здесь</span><br>      <span>bpe</span>[<span>k</span><span>+</span><span>j</span><span>++</span>] <span>=</span> <span>a</span>[<span>i</span>] <span>^</span> <span>196</span> <span>?</span> <span>a</span>[<span>i</span>] : <span>a</span>[<span>++</span><span>i</span>]<span>-</span><span>128</span>;<br>    }<br>    <span>bpe</span>[<span>k</span><span>+</span><span>j</span><span>++</span>] <span>=</span> <span>0</span>;<br>  } <span>else</span> <span>if</span> (<span>i</span> <span>&gt;</span> <span>187</span>) {<br>    <span>// Токены выше 187 — это не выводимые на печать символы asii в диапазоне 0-32 </span><br>    <span>bpe</span>[<span>k</span>] <span>=</span> <span>i</span><span>-</span><span>188</span>;<br>    <span>bpe</span>[<span>k</span><span>+</span><span>1</span>] <span>=</span> <span>0</span>;<br>  }<br>}
```

## Заключение

В самом деле, примечательно, как можно сконцентрировать в нескольких тысячах байт целые десятилетия в развитии машинного обучения. В сущности, здесь есть всё необходимое (кроме фактических весов модели), чтобы вы могли запустить любую современную нейронную сеть. Притом, что я реализовал этот проект в основном из интереса, он хорошо демонстрирует, насколько, в самом деле, _просты_ нейронные сети.
